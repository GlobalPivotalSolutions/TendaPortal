package au.csiro.cass.arch.logProcessing;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.LinkedList;

import org.apache.hadoop.conf.Configuration;
import org.apache.nutch.net.URLFilterException;
import org.apache.nutch.net.URLFilters;
import org.apache.nutch.net.URLNormalizers;

public abstract class LogLineParserBase implements LogLineParser
{
  Date date; // date of the log line
  LinkedList<String> addr; // client IP addresses
  String url; // requested URL
  String canonicalUrl; // canonical URL
  int result; // response code
  int score; // 0 if the hit came from an IP to ignore
  SimpleDateFormat formatter; // date formatter
  boolean good; // true if the line is good
  LogProcessor logProcessor; // environment
  LogSite logSite; // site in processing
  String line; // line submitted for parsing
  URLNormalizers normalizers; //
  URLFilters filters;
  Configuration conf;

  protected LogLineParserBase()
  {
    addr = new LinkedList();
    this.formatter = new SimpleDateFormat( "dd/MMM/yyyy:HH:mm:ss Z" );
    good = false;
  }

  /**
   * Parse a log line
   * 
   * @param ln
   *          - input string. Normally, a line read from a log file.
   * @return true if a valid line was parsed, false if the line should be ignored.
   */
  public boolean parse( String ln )
  {
    return parse( ln, false );
  }

  /**
   * Extract date from a log line
   * 
   * @param ln
   *          input string. Normally, a line read from a log file.
   * @return true if a date was found and parsed, else false.
   */
  public boolean parseDate( String ln )
  {
    return parse( ln, true );
  }

  /**
   * Check if the line is not generated by a source with blacklisted IP address.
   * 
   * @return 1 - good line, 0 - not to be scored, -1 - ignore completely 
   */
  public int validIP()
  {
    if ( logProcessor.isIgnoredIPsEmpty() )
      return 1; // accept all IPs
    // try to determine if these addresses are to be ignored
    int i = 0;
    while ( i < addr.size() )
    {
      String a = (String)addr.get( i );
      String level = logProcessor.getIgnoredIPs().get( a ) ;
      if ( "1".equals( level ) )
                            return -1 ;
      if ( a.equals( "-" ) || level != null )
        addr.remove( i );
      else
        i++;
    }
    if ( addr.size() == 0 )
      return 0; // bad, all addresses are ignored
    return 1;
  }

  /**
   * Filter URLs of common picture files and bogus URLs generated by hackers
   * 
   * @return true if the path refers to a parseable file
   */
  public String validURL( String url )
  {
	 	url = url.toLowerCase() ;
	    if ( url.contains( "?n=http://" ) ||
	         url.length() > logProcessor.getMaxUrlLength() ) // suspicious
	     {  
	       String a = (String)addr.get( 0 ) ;	
	       logProcessor.getIgnoredIPs().put( a, "1" ) ;     
	       return null ;
	     }
	    if ( url.contains( "/robots.txt" ) ) 
	                                        return null ;
	    try
        {
           return filters.filter( url ) ;
        } catch ( URLFilterException e )
        {
          return null ; 
        }
  }

  // Getters and setters below

  public LinkedList getAddr()
  {
    return addr;
  }

  public Date getDate()
  {
    return date;
  }

  public int getCode()
  {
    return result;
  }

  public String getUrl()
  {
    return url;
  }

  public String getCanonicalUrl()
  {
    if ( canonicalUrl == null )
      return url;
    else
      return canonicalUrl;
  }

  public boolean isGood()
  {
    return good;
  }

  public Configuration getConf()
  {
    return conf;
  }

  public void setConf( Configuration conf )
  {
    this.conf = conf;
    normalizers = new URLNormalizers( conf, "logs" );
    filters = new URLFilters( conf );
  }

  public LogSite getLogSite()
  {
    return logSite;
  }

  public void setLogSite( LogSite logSite )
  {
    this.logSite = logSite;
    this.logProcessor = logSite.getBoss();
  }

  public int getScore()
  {
    return score;
  }

  public void setScore( int score )
  {
    this.score = score;
  }

}
