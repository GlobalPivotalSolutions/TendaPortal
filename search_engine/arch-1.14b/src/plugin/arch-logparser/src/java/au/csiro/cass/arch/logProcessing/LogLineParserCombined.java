/*
 * 
 * Copyright (c) CSIRO Astronomy and Space Science
 * Author Arkadi.Kosmynin@csiro.au
 * 
 */
package au.csiro.cass.arch.logProcessing;

import java.net.URL;
import java.text.SimpleDateFormat;
import java.util.StringTokenizer;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Log line parser for combined log format
 * 
 */
public class LogLineParserCombined extends LogLineParserBase
{
 public static final Logger LOG = LoggerFactory.getLogger( LogLineParserCombined.class ) ;
 // extensions of common web pages

 public LogLineParserCombined()
 { 
   super() ;
   this.formatter = new SimpleDateFormat( "dd/MMM/yyyy:HH:mm:ss Z" ) ;
 }
  
  /**
   * Parse a log line 
   * 
   * @param ln - input string. Normally, a line read from a log file.
   * @param forDate - true if only extract date from line, false if do full parsing and checking 
   */
  public boolean parse( String ln, boolean forDate )
  {
   line = ln ;
   try 
   {
    addr.clear() ;
    good = false ;
    date = null ;
  
    // split the line into tokens
    StringTokenizer tn = new StringTokenizer( ln, " " ) ;
    // get all addresses
    int i = 0 ;
    do { 
         String a = tn.nextToken() ;
         i = a.indexOf( ',' ) ;
         if ( i > 0 ) a = a.substring( 0, i ) ; 
         addr.add( a ) ;
       } while( i > 0 ) ; // while comma separated ip addresses

    // This can be done faster because most lines have only one address
    // if ( !forDate && !validIP() ) return false ; // ignore line with this IP 

    tn.nextToken() ; tn.nextToken() ;
    String dateString1 = tn.nextToken().substring( 1 ) ;
    String dateString2 = tn.nextToken() ;
    i = dateString1.indexOf( ']' ) ;
    if ( i < 0 )
      { dateString1 = dateString1 + " " + dateString2.substring( 0, dateString2.length() - 1 ) ;
        tn.nextToken() ; // skip "GET 
      }
        else dateString1 = dateString1.substring( 0, dateString1.length() - 1 ) ;
    try { 
          date = formatter.parse( dateString1 ) ;
        } catch( Exception e ) { return false ; } // must be a bad date
    if ( forDate ) return true ; // date has been found, nothing else matters 
    String urlPath = tn.nextToken() ;
    tn.nextToken() ; // skip HTTP/1.1"
    String code = tn.nextToken() ;
    result = Integer.parseInt( code ) ;
    // consider only served pages, ignore redirections and errors
    if ( result != 200 && result != 304 ) return false ;
    url = logSite.getUrl() + urlPath.substring( 1 ) ;
    if ( !logSite.URLFilter.pass( url ) ) return false ;
    if ( normalizers != null ) url = normalizers.normalize( url, "logs" ) ;
    url = validURL( url ) ;
    if ( url == null )
                    return false ;
    URL u = new URL( url ) ;
    url = u.getPath() ;
    String query = u.getQuery() ;
    if ( query != null && query.length() > 0 ) url += "?" + query ;
    
//    tn.nextToken() ;
//    String ref = tn.nextToken() ;  
//    if ( !cont.validURL( ref ) ) // is referer a valid URL?
//                         return cont ;

    score = validIP() ;
    if ( score > 0 && logProcessor.filterByAgent && !validAgent( ln ) ) score = 0 ;// must be a search engine
    
    good = score >= 0 ;
    // System.out.println( dateString1 + " " + cont.url ) ;
  } catch( Exception e )
   {
	 if ( LOG.isDebugEnabled() )
	 { 
	   String s = "Error parsing line: " + ln ;
	   if ( e.getMessage() != null ) s += " " + e.getMessage() ;
       LOG.debug( s ) ;
	 }  
   }
  
  return good ; 
 }

 /**
 * Check if the line is generated by an accepted user agent. Opera, MSIE
 * and Firefox are more than enough for statistical logs processing.
 * 
 * @param ln user agent substring of the log line being parsed
 * @return true is the agent is good
 */
 static public boolean validAgent( String ln )
  {
   int i = ln.indexOf( "\" \"" ) ;
   if ( i > 0 )
    {
     String agent = ln.substring( i + 3 ).toLowerCase() ;
     if ( agent.indexOf( "opera/" ) >= 0 ) return true ;
     if ( agent.indexOf( "mozilla/" ) >= 0 ) 
        if ( agent.indexOf( "msie" ) > 0 || agent.indexOf( "firefox" ) > 0  )
                                           return true ;
    }
   return false ;
  }
  

}
