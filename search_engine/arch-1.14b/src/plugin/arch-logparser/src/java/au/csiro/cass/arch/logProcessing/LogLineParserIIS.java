/*
 * 
 * Copyright (c) CSIRO Astronomy and Space Science
 * Author Arkadi.Kosmynin@csiro.au
 * 
 */
package au.csiro.cass.arch.logProcessing;

import java.net.URL;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.LinkedList;
import java.util.StringTokenizer;

import org.apache.hadoop.conf.Configuration;
import org.apache.nutch.net.URLNormalizers;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import au.csiro.cass.arch.utils.Utils;

/**
 * Log line parser for combined log format
 * 
 */
public class LogLineParserIIS extends LogLineParserBase
{
 public static final Logger LOG = LoggerFactory.getLogger( LogLineParserIIS.class ) ;

 public LogLineParserIIS()
 { 
   super() ;
   this.formatter = new SimpleDateFormat( "yyyy-MM-dd HH:mm:ss Z" ) ;
 }
  /**
   * Parse a log line 
   * 
   * @param ln - input string. Normally, a line read from a log file.
   * @param forDate - true if only extract date from line, false if do full parsing and checking 
   */
  public boolean parse( String ln, boolean forDate )
  {
   line = ln ;
   try 
   {
    addr.clear() ;
    good = false ;
    date = null ;
  
    if ( ln == null || ln.charAt( 0 ) == '#' ) return false ;
    // split the line into tokens
    StringTokenizer tn = new StringTokenizer( ln, " " ) ;
    String dateString = tn.nextToken() + " " + tn.nextToken() + " UTC" ;
    try { date = formatter.parse( dateString ) ;
        } catch( Exception e ) { return false ; } // must be a bad date
    if ( forDate ) return true ; // date has been found, nothing else matters
    // Skip server address and method name
    tn.nextToken() ; tn.nextToken() ;
    String path = tn.nextToken() ;
    String query = tn.nextToken() ;
    // Skip port number and user name 
    tn.nextToken() ; tn.nextToken() ;
    String clientIP = tn.nextToken() ;
    addr.add( clientIP ) ; // User IP address, assumed to be one per record
    String agent = tn.nextToken() ;

    url = (logSite.getUrl() + path.substring( 1 )).replaceAll( "\\+", "%20" ) ;
    if ( !logSite.URLFilter.pass( url ) ) return false ;
    if ( !query.equals( "-" ) && !path.equals( "/LDAPLogin.aspx" ) && query.indexOf( "=" ) != -1 &&
    	 ( query.indexOf( "w=" ) == -1 || query.indexOf( "h=" ) == -1 ) )
    	 url += "?" + query ;
    if ( normalizers != null ) url = normalizers.normalize( url, "logs" ) ;
    url = validURL( url ) ;
    if ( url == null )
                   return false ;
    URL u = new URL( url ) ;
    url = u.getPath() ;
    query = u.getQuery() ;
    if ( query != null && query.length() > 0 ) url += "?" + query ;
    String code = tn.nextToken() ;
    result = Integer.parseInt( code ) ;
    // consider only served pages, ignore redirections and errors
    if ( result != 200 && result != 304 ) return false ;
    score = validIP() ;
    if ( score > 0 && logProcessor.filterByAgent && !validAgent( agent ) ) score = 0 ; // must be a search engine
    
    good = score >= 0 ;
    // System.out.println( dateString1 + " " + cont.url ) ;
  } catch( Exception e )
   {
	 if ( LOG.isDebugEnabled() )
	 { 
	   String s = "Error parsing line: " + ln ;
	   if ( e.getMessage() != null ) s += " " + e.getMessage() ;
       LOG.debug( s ) ;
	 }  
   }
  
  return good ; 
 }

 /**
 * Check if the line is generated by an accepted user agent. Opera, MSIE
 * and Firefox are more than enough for statistical logs processing.
 * 
 * @param ln user agent substring of the log line being parsed
 * @return true is the agent is good
 */
 static public boolean validAgent( String agent )
  {
     agent = agent.toLowerCase() ;
     if ( agent.contains( "opera/" ) ) return true ;
     if ( agent.contains( "mozilla/" ) ) 
        if ( agent.contains( "msie" ) || agent.contains( "firefox" ) )
                                           return true ;
   return false ;
  }
  

}
